{
  "name": "Rakshika Bagavathy",
  "tagline": "Google Summer of Code '16 with BRL-CAD",
  "body": "### ﻿Introduction to the project\r\n\r\nA little intro into the project. BRL-CAD's manifold meshes are represented by the type called bag of triangles (bot). The meshes are not perfect always, they might become defective. It might happen during import-export or during *, etc. And defective meshes are not desirable. So, we have a a problem here. And the solution is my project. \r\n\r\nSpecifically we focus on the geometric defects such as gaps, overlaps, T-joints, and holes, and topological defects such as singular vertices, singular edges, and inconsistent orientation of the triangles in the mesh.\r\n\r\nAfter submitting the proposal\r\n\r\nA little while after i had submitted the proposal, on the BRL-CAD IRS channel, OpenSCAD's Marius Kintel (nick: kintel) asked if there could be a portable module for mesh healing that could be used by both BRL-CAD and OpenSCAD. After my proposal got accepted, we decided to go forward with the portable module idea. \r\n\r\nNow, how we'd implement the portable module was of interest to all of us. Sean and Daniel from BRL-CAD suggested a few methods and we discussed the pro and cons of both.\r\n\r\nAt this point my mentor Daniel had suggested we go with a generic container of an intermediate polygonal mesh using non-generic programming. That is we define an intermediate structure that will be used to complete the mesh healing functionalities. And we implement the structure differently for the two organizations. We do them using a set of functions that get the attributes from the native structures. In this way, we have an intermediate structure that can talk to both the native structures.\r\n\r\nThe method i had suggested, in essence, was to create a structure that is in a sense a “union” of the attributes of both the native structures. The only conversion process here will be to set those attributes of the intermediate structure to those of each organisation (the ones that apply). For the attributes that don't apply to one of the organisations, we set it to NULL. In this way too, we have an intermediate mesh that encompasses the properties of both the meshes and one that can be used in the portable module. \r\n\r\nAt this point, we are yet to decide on the method to go forward with. \r\n\r\n### Week 1\r\n\r\nAfter outlining the methods for the portable module, the decision left to take was which one to go with. I decided to go with the Daniel's method of using an abstract class to represent the intermediate polygonal structure, which will access the native mesh types to obtain any information. This was because the method I suggested will tend to clutter things, and will unnecessarily complicate things. A problem arose due to the difference between the two organisation's format of representation. BRL-CAD uses an indexed format, while OpenSCAD uses an unindexed format. \r\n\r\nIf there is no need for the intermediate mesh to store the vertices in an indexed format, then the issue is trivial. That is, if the only task of the intermediate polygonal structure is to be able to convert to the doubly-connected edge list (that we will use for the algorithms) smoothly, the abstract classes method can be used. This cannot be answered now. Once i write the draft algorithms, things will pan out a bit more. \r\n\r\nSo primarily, for storing the geometry we are using the abstract class and for processing we are using the doubly-connected edge list. \r\n\r\nWhat essentially happens on both softwares is we fire up the command/invoke the functionality from the GUI. This links up to the conversion file specific to the softwares. The intermediate polygonal_mesh abstract class is just a container for the native mesh types. This class will have virtual methods that will be implemented specific to the two softwares. Now, with the intermediate container set, we create the DCEL with the help of the virtual functions. With the help of the DCEL, we implement the healing algorithms. \r\n\r\nAfter the process is done, we'll recalculate the normals for the BRL-CAD mesh since it includes this attribute information in its structure. No post-processing is required for the PolySet class in OpenSCAD. \r\n\r\nDCEL:\r\n\r\nThe vertex, edge and face records for the DCEL have been defined. The functions required for obtaining/adding/removing information will be defined as and when we require them while implementing the healing algorithms.\r\n\r\nPolygonalMesh abstract class:\r\n\r\nWe won't need any attributes, since we won't be caching any information. The DCEL will do that job. As for functions, for now we define those functions that we will need for converting the PolygonalMesh object to the doubly-connected edge list object. Later on we will add functions that we will use to add/remove information from the native structures, depending on the situations. Suppose we need to add a vertex, we would be requires to know if it's a part of a face/a stand-alone vertex that we will create a face for next. \r\n\r\nWhen we modify the structure of the mesh i.e. add/remove any information, we'll do it simultaneously for both the structures because we don't want to be converting from the DCEL to the PolygonalMesh intermediate class. \r\n\r\n### Week 2\r\n\r\nThis week, I mainly worked on the conversion files for both the organizations. The abstract class defined all the functions that will be required for the conversion to the DCEL. Taking into consideration the order in which the data conversion should take place, I.e. the setting of the attributes of the DCEL such that all dependencies could be handled, the functions were written. Some functions were independent of the native mesh structures - those like setting the incident edge for a vertex. These depended only on the attributes of the DCEL that were already set. So these functions were implemented common to both. The other specific functions were defined and declared in the two derived classes.\r\n\r\nNext step was the UI for the mesh healing. This heal command could have options that indicate healing of only a certain type of defect - say gaps and T-joints. This will be taken care of later on.\r\nFor BRL-CAD, this will be an mged command with TCL binding. For OpenSCAD, an import command with an attribute indicating that the mesh needs to be fixed (again separate options for separate defects can be accommodated) can be used. These commands will invoke the conversion process and then the mesh healing functions. \r\n\r\n### Week 3\r\n\r\nI started with the first algorithm in my proposal, namely the zippering gaps algorithm. This algorithm is meant for gaps within a certain tolerance. This will be decided appropriately. For those greater than that there is the stitching algorithm. \r\n\r\nHow this algorithm works is we first identify a boundary (free-edges) chain in the mesh and make sure it's not a cycle. If it is, then it's either the boundary of the overall mesh or is a hole. Either way, we don't want it. So, given a start and an end half-edge we implement the zipper gaps algorithm.\r\n\r\nWe look for a feature pair for each vertex on the boundary chain, and calculate the error measure. We maintain a priority queue that will pop the feature pair with the least error measure. The feature for a vertex can either be a vertex or an edge. This depends on the closest edge. The distance from a vertex to a closest edge will be the perpendicular distance if an orthogonal projection is possible, else it'll be the shortest between the vertex and the closer endpoint. This way we either set the feature_edge or the feature_vertex, but not both, for a vertex. \r\nThis closest edge cannot have a bounded face incident on it - meaning it's not a free-edge. It cannot be incident on the current vertex being considered. Also, the line joining the vertex to the closest edge (be it the orthogonal projection or the closer end point) cannot cross any face other than the unbounded face - meaning it should be a valid diagonal. \r\n\r\nWhile zippering the gap, we pop the feature pair with the minimum error measure. Only if this measure is within the tolerance for gaps, we continue. Else we break out of the loop, since every error measure after this will only be greater. We stitch/ fill those defects. \r\n\r\nSince the feature vertex of a vertex on the free-edge chain could be a vertex on the free-edge chain itself, its coordinates could possibly change. And hence, the error measure too. Thus every time we pop a new vertex, we need to go through all the elements of the priority queue and:\r\n\r\n1. Check if there are any invalid features and recalculate the features for those vertices\r\n2. Check if the distance measure is up to date.\r\n\r\nWe pop the feature pair with the minimum error measure. If the feature is a vertex, we move both the vertices to the mid point of the line joining those two. If the feature is an edge, we introduce a new vertex on the orthogonal projection of the vertex on the edge and split the face incident on that edge. We update the vertex, edge, and face records accordingly for both cases. \r\n\r\nAs and when we update the DCEL, we update the native structure too. This is important to keep all data consistent, that is there must be a synchronization between the two structures. \r\n\r\n### Week 4\r\n\r\nOne main concern was the determining of the closest edge for a vertex v. Checking whether a line intersects a face geometrically might not yield accurate results. So I came up with an approach.\r\n\r\nWhile considering an edge for the position of the closest edge, if it is still eligible (after checking for the unbounded face incidence and non-incidence on the vertex), we check if the edge's incident face contains the vertex v. If not check check for the same with the edge's twin. If either of the conditions fail, make this edge ineligible and move on to the next edge. If not, check if the line joining the vertex v to the edge intersects any of the other two edges in the triangle. If true, take the face incident on the twin of the intersected edge and check if the vertex is contained. \r\nIf the line does not intersect the other two edges, it is an eligible edge, so we continue to calculating the orthogonal distance. Here what we essentially do is make use of the DCEL structure to traverse the faces intersected by the line from the vertex v to the edge being considered. \r\n\r\nSetting the unbounded face id to the number of faces gave rise to problems while adding and deleting faces, so it was set to zero and all the functions were updated accordingly. \r\n\r\nI will be testing my code with the 'heal' command.\r\n\r\n### Week 5\r\n\r\nI will be testing the zippering gaps module this week. So, i first create a function - analyse_heal_bot() that will link the TCL command function ged_heal() to the zippering gaps code. This function looks for free edge chains in the mesh that are not cycles (hole/boundary of the mesh) and passes them on for zippering.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}